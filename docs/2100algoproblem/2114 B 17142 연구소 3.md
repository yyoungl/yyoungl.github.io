---
layout: default
title: ë°±ì¤€ 17141 ì—°êµ¬ì†Œ 2 Java
nav_order: 2113
parent: Algorithm Problems
---

# **17142 ì—°êµ¬ì†Œ 3 Java**

## **ë¬¸ì œ [ðŸŒ](https://www.acmicpc.net/problem/17142)**

ì¸ì²´ì— ì¹˜ëª…ì ì¸ ë°”ì´ëŸ¬ìŠ¤ë¥¼ ì—°êµ¬í•˜ë˜ ì—°êµ¬ì†Œì— ìŠ¹ì›ì´ê°€ ì¹¨ìž…í–ˆê³ , ë°”ì´ëŸ¬ìŠ¤ë¥¼ ìœ ì¶œí•˜ë ¤ê³  í•œë‹¤. ë°”ì´ëŸ¬ìŠ¤ëŠ” í™œì„± ìƒíƒœì™€ ë¹„í™œì„± ìƒíƒœê°€ ìžˆë‹¤. ê°€ìž¥ ì²˜ìŒì— ëª¨ë“  ë°”ì´ëŸ¬ìŠ¤ëŠ” ë¹„í™œì„± ìƒíƒœì´ê³ , í™œì„± ìƒíƒœì¸ ë°”ì´ëŸ¬ìŠ¤ëŠ” ìƒí•˜ì¢Œìš°ë¡œ ì¸ì ‘í•œ ëª¨ë“  ë¹ˆ ì¹¸ìœ¼ë¡œ ë™ì‹œì— ë³µì œë˜ë©°, 1ì´ˆê°€ ê±¸ë¦°ë‹¤. ìŠ¹ì›ì´ëŠ” ì—°êµ¬ì†Œì˜ ë°”ì´ëŸ¬ìŠ¤ Mê°œë¥¼ í™œì„± ìƒíƒœë¡œ ë³€ê²½í•˜ë ¤ê³  í•œë‹¤.

ì—°êµ¬ì†ŒëŠ” í¬ê¸°ê°€ NÃ—Nì¸ ì •ì‚¬ê°í˜•ìœ¼ë¡œ ë‚˜íƒ€ë‚¼ ìˆ˜ ìžˆìœ¼ë©°, ì •ì‚¬ê°í˜•ì€ 1Ã—1 í¬ê¸°ì˜ ì •ì‚¬ê°í˜•ìœ¼ë¡œ ë‚˜ëˆ„ì–´ì ¸ ìžˆë‹¤. ì—°êµ¬ì†ŒëŠ” ë¹ˆ ì¹¸, ë²½, ë°”ì´ëŸ¬ìŠ¤ë¡œ ì´ë£¨ì–´ì ¸ ìžˆìœ¼ë©°, ë²½ì€ ì¹¸ í•˜ë‚˜ë¥¼ ê°€ë“ ì°¨ì§€í•œë‹¤. í™œì„± ë°”ì´ëŸ¬ìŠ¤ê°€ ë¹„í™œì„± ë°”ì´ëŸ¬ìŠ¤ê°€ ìžˆëŠ” ì¹¸ìœ¼ë¡œ ê°€ë©´ ë¹„í™œì„± ë°”ì´ëŸ¬ìŠ¤ê°€ í™œì„±ìœ¼ë¡œ ë³€í•œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, ì•„ëž˜ì™€ ê°™ì´ ì—°êµ¬ì†Œê°€ ìƒê¸´ ê²½ìš°ë¥¼ ì‚´íŽ´ë³´ìž. 0ì€ ë¹ˆ ì¹¸, 1ì€ ë²½, 2ëŠ” ë°”ì´ëŸ¬ìŠ¤ì˜ ìœ„ì¹˜ì´ë‹¤.

```
2 0 0 0 1 1 0
0 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 0 0
0 0 0 2 0 1 1
0 1 0 0 0 0 0
2 1 0 0 0 0 2
```

M = 3ì´ê³ , ë°”ì´ëŸ¬ìŠ¤ë¥¼ ì•„ëž˜ì™€ ê°™ì´ í™œì„± ìƒíƒœë¡œ ë³€ê²½í•œ ê²½ìš° 6ì´ˆë©´ ëª¨ë“  ì¹¸ì— ë°”ì´ëŸ¬ìŠ¤ë¥¼ í¼ëœ¨ë¦´ ìˆ˜ ìžˆë‹¤. ë²½ì€ -, ë¹„í™œì„± ë°”ì´ëŸ¬ìŠ¤ëŠ” \*, í™œì„± ë°”ì´ëŸ¬ìŠ¤ëŠ” 0, ë¹ˆ ì¹¸ì€ ë°”ì´ëŸ¬ìŠ¤ê°€ í¼ì§€ëŠ” ì‹œê°„ìœ¼ë¡œ í‘œì‹œí–ˆë‹¤.

```
* 6 5 4 - - 2
5 6 - 3 - 0 1
4 - - 2 - 1 2
3 - 2 1 2 2 3
2 2 1 0 1 - -
1 - 2 1 2 3 4
0 - 3 2 3 4 *
```

ì‹œê°„ì´ ìµœì†Œê°€ ë˜ëŠ” ë°©ë²•ì€ ì•„ëž˜ì™€ ê°™ê³ , 4ì´ˆë§Œì— ëª¨ë“  ì¹¸ì— ë°”ì´ëŸ¬ìŠ¤ë¥¼ í¼ëœ¨ë¦´ ìˆ˜ ìžˆë‹¤.

```
0 1 2 3 - - 2
1 2 - 3 - 0 1
2 - - 2 - 1 2
3 - 2 1 2 2 3
3 2 1 0 1 - -
4 - 2 1 2 3 4
* - 3 2 3 4 *
```

ì—°êµ¬ì†Œì˜ ìƒíƒœê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ëª¨ë“  ë¹ˆ ì¹¸ì— ë°”ì´ëŸ¬ìŠ¤ë¥¼ í¼ëœ¨ë¦¬ëŠ” ìµœì†Œ ì‹œê°„ì„ êµ¬í•´ë³´ìž.

#### **ìž…ë ¥**

ì²«ì§¸ ì¤„ì— ì—°êµ¬ì†Œì˜ í¬ê¸° N(4 â‰¤ N â‰¤ 50), ë†“ì„ ìˆ˜ ìžˆëŠ” ë°”ì´ëŸ¬ìŠ¤ì˜ ê°œìˆ˜ M(1 â‰¤ M â‰¤ 10)ì´ ì£¼ì–´ì§„ë‹¤.

ë‘˜ì§¸ ì¤„ë¶€í„° Nê°œì˜ ì¤„ì— ì—°êµ¬ì†Œì˜ ìƒíƒœê°€ ì£¼ì–´ì§„ë‹¤. 0ì€ ë¹ˆ ì¹¸, 1ì€ ë²½, 2ëŠ” ë¹„í™œì„± ë°”ì´ëŸ¬ìŠ¤ì˜ ìœ„ì¹˜ì´ë‹¤. 2ì˜ ê°œìˆ˜ëŠ” Më³´ë‹¤ í¬ê±°ë‚˜ ê°™ê³ , 10ë³´ë‹¤ ìž‘ê±°ë‚˜ ê°™ì€ ìžì—°ìˆ˜ì´ë‹¤.

#### **ì¶œë ¥**

ì—°êµ¬ì†Œì˜ ëª¨ë“  ë¹ˆ ì¹¸ì— ë°”ì´ëŸ¬ìŠ¤ê°€ ìžˆê²Œ ë˜ëŠ” ìµœì†Œ ì‹œê°„ì„ ì¶œë ¥í•œë‹¤. ë°”ì´ëŸ¬ìŠ¤ë¥¼ ì–´ë–»ê²Œ ë†“ì•„ë„ ëª¨ë“  ë¹ˆ ì¹¸ì— ë°”ì´ëŸ¬ìŠ¤ë¥¼ í¼ëœ¨ë¦´ ìˆ˜ ì—†ëŠ” ê²½ìš°ì—ëŠ” -1ì„ ì¶œë ¥í•œë‹¤.

### **ì ‘ê·¼ ë°©ë²•**

í•œ ë¬¸ì œë¥¼ í•œ ë‹¬ ë™ì•ˆ í‘¸ëŠ” ì‚¬ëžŒì´ ìžˆë‹¤!?

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FBfA2Q%2FbtsyLtm7j2c%2FJcjmR5Fr322VtiKdrwQspk%2Fimg.png)

~ê·¸ ì‚¬ëžŒì´ ë°”ë¡œ ë‚˜ì˜ˆìš”â€¦~

[ì—°êµ¬ì†Œ 2](https://letusgrow.tistory.com/94) ì™€ ë¹„ìŠ·í•œ ë“¯ ì•ˆ ë¹„ìŠ·í•œ ë“¯â€¦. ê°€ìž¥ ë‹¤ë¥¸ ì ì€ ë°”ì´ëŸ¬ìŠ¤ê°€ **í™œì„±í™” ë°”ì´ëŸ¬ìŠ¤/ë¹„í™œì„±í™” ë°”ì´ëŸ¬ìŠ¤**ë¡œ ë‚˜ëˆ ì§„ë‹¤ëŠ” ê²ƒì´ë‹¤.

#### **ë¹„í™œì„±í™” ë°”ì´ëŸ¬ìŠ¤ & 0ì¸ ë¶€ë¶„ ì²´í¬í•˜ê¸°**

ê·¸ëŸ¼ í™œì„±í™” ë°”ì´ëŸ¬ìŠ¤ëŠ” ë¬´ì—‡ì´ ë‹¤ë¥¸ê°€? í•˜ë©´â€¦ ë°”ì´ëŸ¬ìŠ¤ê°€ ë¹„í™œì„±í™” ë°”ì´ëŸ¬ìŠ¤ ìœ„ì¹˜ì— ê°€ë©´ ê·¸ ë°”ì´ëŸ¬ìŠ¤ ë˜í•œ í™•ì‚°ë  ìˆ˜ ìžˆë‹¤ëŠ” ê²ƒì´ë‹¤. ë”°ë¡œ ì²˜ë¦¬í•´ ì¤˜ì•¼ í•˜ë‚˜ ì‹¶ì—ˆì§€ë§Œ, ê·¸ëƒ¥ ë°©ë¬¸ ì²˜ë¦¬ë¥¼ í•˜ì§€ ì•Šê³  qì— ë„£ì–´ ì£¼ë©´ ë˜ì—ˆë‹¤.

```
while (!q.isEmpty() && zero > 0) {
	Node curr = q.poll();
	int r = curr.r;
	int c = curr.c;
	for (int d = 0; d < 4; d++) {
		int nr = r + dr[d];
		int nc = c + dc[d];
		if (isValid(nr, nc) && !visited[nr][nc]) {
		// 0ì¼ ë•Œë§Œ zeroCnt ê°ì†Œ
			if (map[nr][nc] == 0)
				zero--;
		// 0ì¼ ë•Œ, 2ì¼ ë•Œ ëª¨ë‘ ë°©ë¬¸ ì²´í¬ í•´ ì£¼ê³  qì— ë‹´ê¸°
			visited[nr][nc] = true;
			q.add(new Node(nr, nc));
			vCnt[nr][nc] = vCnt[r][c] + 1;
		}
	}
}
```

#### **ì‹œê°„ & ë©”ëª¨ë¦¬ ì´ˆê³¼ ì´ìŠˆ**

ë°”ì´ëŸ¬ìŠ¤ê°€ ë‹¤ í¼ì¡ŒëŠ”ì§€ í™•ì¸í•  ë•Œ ë‹¤ì‹œ í•œë²ˆ ë°©ë¬¸ ë°°ì—´ì„ ë´¤ëŠ”ë°, ì´ë ‡ê²Œ ëŒë ¤ ë³´ë‹ˆê¹Œ ì‹œê°„ ì´ˆê³¼ê°€ ë‚¬ë‹¤. ì²˜ìŒì— 0ì¸ ì¹¸ì˜ ê°œìˆ˜ë¥¼ ì„¸ê³  0ì´ ë˜ì—ˆëŠ”ì§€, ì•„ë‹ˆë©´ 0ë³´ë‹¤ í° ê°’ìœ¼ë¡œ ë‚¨ì•„ ìžˆëŠ”ì§€ í™•ì¸í•´ì„œ ë°”ì´ëŸ¬ìŠ¤ê°€ ëª¨ë‘ í¼ì¡ŒëŠ”ì§€, ì•„ë‹ˆë©´ ì‹¤íŒ¨í–ˆëŠ”ì§€ í™•ì¸í–ˆë‹¤.

ì¹´ìš´íŠ¸ ë°°ì—´ì„ ë§Œë“¤ì–´ ë²½ì„ ë°©ë¬¸ ì²´í¬ í•˜ê³ , ê°€ìž¥ í° ì¹´ìš´íŠ¸ ê°’ì„ ê°±ì‹ í•´ ì£¼ëŠ” ê±´ ì•žì„  [ì—°êµ¬ì†Œ](https://letusgrow.tistory.com/93), [ì—°êµ¬ì†Œ 2](https://letusgrow.tistory.com/94) ë¬¸ì œì™€ ê°™ë‹¤.

ì§€ê¸ˆ ë³´ë‹ˆê¹Œ ë²½(1)ì¸ ë¶€ë¶„ì„ ë”°ë¡œ ì²´í¬í•´ ì¤¬ëŠ”ë°, bfs íƒìƒ‰ì„ í•  ë•Œ ì¡°ê±´ì„ map\[nr\]\[nc\]!=1ë¡œ ê±¸ê³  ì¹´ìš´íŠ¸ ë°°ì—´ì—ì„œ ìµœëŒ€ê°’ì„ ê°±ì‹ í–ˆì–´ë„ ëì„ ê²ƒ ê°™ë‹¤.

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FMhuKY%2FbtsyIMOiRmY%2FyawJzkAaQXVcmnsVgmU8gK%2Fimg.png)

ë°©ê¸ˆ ì‹œë„í•´ ë³´ë‹ˆ ë©”ëª¨ë¦¬ ìƒìœ¼ë¡œë‚˜ ì‹œê°„ ìƒìœ¼ë¡œë‚˜ í¬ê²Œ ë‹¤ë¥´ì§€ ì•Šë‹¤â€¦.

ë¬¸ì œë¥¼ ì²˜ìŒ ë´¤ì„ ë•ŒëŠ” ê°ì¡°ì°¨ ì•ˆ ì™”ëŠ”ë°, ì´ë²ˆì—ëŠ” ì–´ë–»ê²Œ ì ‘ê·¼í•˜ëŠ” ê²ƒì´ ì¢‹ì„ì§€ ìƒê°ì´ ë‚¬ê³ , í˜¼ìž íž˜ìœ¼ë¡œ ë‹¤ì‹œ í’€ì—ˆë‹¤ëŠ” ì ì´ ë¿Œë“¯í•œ ë¬¸ì œì˜€ë‹¤. ì„±ìž¥í–ˆìŒì„ ëŠê»´â€¦â˜†â˜…

## **Full Solution**

```
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Main {

	static int N;
	static int M;
	static int vNum;
	static int[] dr = { -1, 1, 0, 0 };
	static int[] dc = { 0, 0, -1, 1 };
	static ArrayList<Node> virus;
	static int answer;
	static int[][] map;

	static class Node {
		int r;
		int c;

		public Node(int r, int c) {
			super();
			this.r = r;
			this.c = c;
		}

		@Override
		public String toString() {
			return "Node [r=" + r + ", c=" + c + "]";
		}

	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int zero = 0;
		N = sc.nextInt();
		M = sc.nextInt();

		virus = new ArrayList<>();
		answer = N * N;

		map = new int[N][N];

		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				int temp = sc.nextInt();
				map[i][j] = temp;
				if (temp == 2) {
					virus.add(new Node(i, j));
				}
				if (temp == 0)
					zero++;
			}
		}
		if (zero == 0)
			System.out.println(0);
		else {
			vNum = virus.size();
			Node[] comb = new Node[M];
			boolean[] chk = new boolean[vNum];

			combination(chk, 0, comb, 0, zero);

			if (answer == N * N)
				System.out.println(-1);
			else
				System.out.println(answer);

		}

	}

	static void combination(boolean[] chk, int idx, Node[] result, int start, int zero) {
		if (idx == M) {
			Node[] temp = Arrays.copyOf(result, M);

			bfs(temp, zero);

			return;
		}

		for (int i = start; i < vNum; i++) {
			if (!chk[i]) {
				chk[i] = true;
				result[idx] = virus.get(i);
				combination(chk, idx + 1, result, i + 1, zero);
				chk[i] = false;
			}
		}
	}

	static void bfs(Node[] temp, int zero) {
		boolean[][] visited = new boolean[N][N];

		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				if (map[i][j] == 1)
					visited[i][j] = true;
			}
		}

		Queue<Node> q = new LinkedList<>();
		int[][] vCnt = new int[N][N];
		for (Node n : temp) {
			q.add(n);
			visited[n.r][n.c] = true;
			vCnt[n.r][n.c] = 0;
		}

		while (!q.isEmpty() && zero > 0) {
			Node curr = q.poll();
			int r = curr.r;
			int c = curr.c;
			for (int d = 0; d < 4; d++) {
				int nr = r + dr[d];
				int nc = c + dc[d];
				if (isValid(nr, nc) && !visited[nr][nc]) {
					if (map[nr][nc] == 0)
						zero--;
					visited[nr][nc] = true;
					q.add(new Node(nr, nc));
					vCnt[nr][nc] = vCnt[r][c] + 1;
				}

			}

		}

		boolean isOkay = true;
		int max = 0;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				int now = map[i][j];
				if (now == 1 || now == 2)
					visited[i][j] = true;
				if (!visited[i][j])
					isOkay = false;
				max = Math.max(max, vCnt[i][j]);
			}
		}

		if (isOkay)
			answer = Math.min(max, answer);

	}

	static boolean isValid(int r, int c) {
		if (r < 0 || r >= N || c < 0 || c >= N)
			return false;
		return true;
	}

}
```

### **Full Solution 2**

```
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Main {

	static int N;
	static int M;
	static int vNum;
	static int[] dr = { -1, 1, 0, 0 };
	static int[] dc = { 0, 0, -1, 1 };
	static ArrayList<Node> virus;
	static int answer;
	static int[][] map;

	static class Node {
		int r;
		int c;

		public Node(int r, int c) {
			super();
			this.r = r;
			this.c = c;
		}

		@Override
		public String toString() {
			return "Node [r=" + r + ", c=" + c + "]";
		}

	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int zero = 0;
		N = sc.nextInt();
		M = sc.nextInt();

		virus = new ArrayList<>();
		answer = N * N;

		map = new int[N][N];

		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				int temp = sc.nextInt();
				map[i][j] = temp;
				if (temp == 2) {
					virus.add(new Node(i, j));
				}
				if (temp == 0)
					zero++;
			}
		}
		if (zero == 0)
			System.out.println(0);
		else {
			vNum = virus.size();
			Node[] comb = new Node[M];
			boolean[] chk = new boolean[vNum];

			combination(chk, 0, comb, 0, zero);

			if (answer == N * N)
				System.out.println(-1);
			else
				System.out.println(answer);

		}

	}

	static void combination(boolean[] chk, int idx, Node[] result, int start, int zero) {
		if (idx == M) {
			Node[] temp = Arrays.copyOf(result, M);

			bfs(temp, zero);

			return;
		}

		for (int i = start; i < vNum; i++) {
			if (!chk[i]) {
				chk[i] = true;
				result[idx] = virus.get(i);
				combination(chk, idx + 1, result, i + 1, zero);
				chk[i] = false;
			}
		}
	}

	static void bfs(Node[] temp, int zero) {
		boolean[][] visited = new boolean[N][N];

		Queue<Node> q = new LinkedList<>();
		int[][] vCnt = new int[N][N];
		for (Node n : temp) {
			q.add(n);
			visited[n.r][n.c] = true;
			vCnt[n.r][n.c] = 0;
		}

		while (!q.isEmpty() && zero > 0) {
			Node curr = q.poll();
			int r = curr.r;
			int c = curr.c;
			for (int d = 0; d < 4; d++) {
				int nr = r + dr[d];
				int nc = c + dc[d];
				if (isValid(nr, nc) && !visited[nr][nc] && map[nr][nc] != 1) {
					if (map[nr][nc] == 0)
						zero--;
					visited[nr][nc] = true;
					q.add(new Node(nr, nc));
					vCnt[nr][nc] = vCnt[r][c] + 1;
				}

			}

		}

		boolean isOkay = true;
		int max = 0;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				int now = map[i][j];
				if (now == 1 || now == 2)
					visited[i][j] = true;
				if (!visited[i][j])
					isOkay = false;
				max = Math.max(max, vCnt[i][j]);
			}
		}

		if (isOkay)
			answer = Math.min(max, answer);

	}

	static boolean isValid(int r, int c) {
		if (r < 0 || r >= N || c < 0 || c >= N)
			return false;
		return true;
	}

}
```
