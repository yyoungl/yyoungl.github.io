---
layout: default
title: JAVA 기본 문법 (2)
nav_order: 103
description: Java 기본 문법
parent: Java 언어
---

230717

# **Java 기본**

## **변수와 자료형, 형 변환, 연산자, 제어/반복문**

---

### **정의**

- 데이터를 저장할 메모리의 위치를 나타내는 이름
- 메모리 상에 데이터를 보관할 수 있는 공간을 확보
- 적절한 메모리 공간을 확보하기 위해서 변수의 타입 등장
- ‘=’ 를 통해서 CPU에게 연산 작업을 의뢰

#### **메모리의 단위**

- 0과 1을 표현하는 bit
- 8bit = 1byte

### **변수 (Variable)**

- 대소문자를 구분한다
- 공백은 허용되지 않는다
- 숫자로 시작할 수 없다
- ‘$’와 ‘\_’를 변수 이름에 사용할 수 있다. 이외 특수문자는 허용되지 않는다
- 예약어(Keyword, 자바 문법을 위해서 미리 지정되어 있는 단어)는 사용할 수 없다
- 합성어의 경우 주로 camelCase를 활용한다
- 한글을 이용한 변수 작명 가능 (권장 X)

자바 예약어

abstract, boolean, break, byte, cases, catch, char, class, const, continue, default, do, double, else, extends, final, finally, float, for, goto, if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while

자료형 (Data Type)

- 기본 자료형 Primitive Type 과 참조 자료형 Reference Type (기본 자료형 외 모든 것)
- 기본 자료형: 미리 정해진 크기의 Memory Size 표현, 변수 자체에 값 저장

### **데이터의 타입**

#### **데이터의 크기**

| 8 bit         | 1 byte      |
| ------------- | ----------- |
| 1024 byte     | 1 kilobyte  |
| 1024 kilobyte | 1 megabyte  |
| 1024 megabyte | 1 gigabyte  |
| 1024 gigabyte | 1 megabyte  |
| 1024 terabyte | 1 petabyte  |
| 1024 petabyte | 1 exabyte   |
| 1024 exabyte  | 1 zettabyte |

### **정수형**

데이터 타입 메모리의 크기 표현 가능 범위

| 데이터 타입 | 메모리 크기 | 표현 가능 범위                                        |
| ----------- | ----------- | ----------------------------------------------------- |
| byte        | 1 byte      | \-128~127                                             |
| short       | 2 byte      | \-32,768~32,767                                       |
| int         | 4 byte      | 2,147,483,648~2,147,483,647                           |
| long        | 8 byte      | 9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |

들어갈 데이터의 크기와 다른 요소에 따라서 변수의 종류를 적당히 선정해야 메모리를 아낄 수 있지만, 오늘날 메모리 용량은 늘어났기 때문에 결과적으로 정수를 저장할 때는 int를 사용하면 된다.

int형을 처리할 때 CPU의 처리 속도가 빠르고, int는 충분히 큰 수를 표현할 수 있는 데이터 타입이기 때문이다.

### **실수형**

| float  | 4byte | ±(1.40129846432481707e-45 ~ 3.40282346638528860e+38)     |
| ------ | ----- | -------------------------------------------------------- |
| double | 8byte | ±(4.94065645841246544e-324d ~ 1.79769313486231570e+308d) |

실수형은 double 쓰는 것을 권장~!

### **문자**

| char | 2byte | 모든 유니코드 문자 |
| ---- | ----- | ------------------ |

#### **선언**

1.  자료형 변수명;
2.  int age; String name;

#### **저장 (할당)**

1.  변수명 = 저장할 값;
2.  age = 30; name = "철수";

초기화

1.  자료형 변수명 = 저장할 값;
2.  int age = 30;

### **형 변환 (Type Casting)**

#### **자동 (묵시적, 암묵적) 형변환이 가능한 방향**

byte → short → int → long → float → double

char → int → long → float → double

#### **데이터 형 변환**

- 묵시적 (암묵적) Implicit Casting

  - 범위가 넓은 데이터 형에 좁은 데이터 형을 대입하는 것
  - byte b = 100; int i = b;
  - 묵시적 형 변환 가능한 방향
    - byte → short → int → long → float → double
    - char → int → long → float → double

- 명시적 Explicit Casting
  1.  범위가 좁은 데이터 형에 넓은 데이터 형을 대입하는 것
  2.  형 변환 연산자 사용 - (타입) 값;
  3.  int i = 100; byte b = i; (X) byte b = (byte) i; (O)

## **연산자**

---

### **연산자 종류**

| 종류          | 연산기호                                  | 결합 방향 | 우선순위 |
| ------------- | ----------------------------------------- | --------- | -------- |
| 최우선 연산자 | ().참조연산자 \[\] 배열 참조 연산자       |           |          |
| 단항 연산자   | ++ -- +(부호) -(부호) ~ ! (type): 형 변환 | ←         | 높       |
| 산술 연산자   | \* / % + (덧셈) - (뺄셈) << >> >>>        | → → →     |          |
| 비교 연산자   | < > <= >= instanceof \== !=               | → →       |          |
| 논리 연산자   | & ^ \| && \|\|                            | → → → → → |          |
| 삼항 연산자   | ? :                                       | →         |          |
| 대입 연산자   | \= \*= /= %= += -= <<= >>= >>>= &= ^= \|= | ←         | 낮음     |

!! 대소 비교, 동일 비교 중 따지자면 대소 비교가 우선순위가 더 높다

#### **단항 연산자**

증감 연산자 ++, --

- 피연산자의 값을 1 증가, 감소시킨다
- 전위형(prefix) ++i
- 후위형(postfix) i--

#### **부호 연산자 +, -**

- 숫자가 양수임을 표시 +
- 피연산자의 부호를 반대로 변경한 결과를 반환 -

#### **논리 부정 연산자 !**

- 논리 값을 반전

#### **비트 부정 연산자 ~**

- 비트 값을 반전 (부호 반전)

#### **형 변환 연산자 (Type)**

```
package java03.operator;

public class Op01_단항연산자 {
	//다음 중 올바른 값을 채워 넣으시오.
	public static void main(String[] args) {
		int a = 5;
		System.out.println( a++ );  //
		System.out.println( ++a );	//
		System.out.println( --a );	//
		System.out.println( a );	//
		System.out.println( a-- );	//
		System.out.println( a++ );	//

		System.out.println(-a);		//
		System.out.println(~a);		//

		System.out.println(!false); //
	}
}
```

#### **산술 연산자**

- 곱하기 연산자 \*
- 나누기 연산자 /
- 나머지 연산자 %
- 더하기 연산자 +
- 빼기 연산자 -

```
정수와 정수의 연산 = 정수
정수와 실수의 연산 = 실수
```

#### **비교 연산자**

- 대소 비교 연산: \>, >=, <, <=
- 동등 비교 연산: String 변수 비교: equlas() 사용
  - 이외 정수/실수 등은 \==, !=
- 객체 타입 비교 연산: instanceof

#### **논리 연산자**

효율적인 연산 가능 (short circuit evaluation)

- &&: 논리 곱 (AND) 피연산자 모두가 true일 경우에만 true
- ||: 논리 합 (OR) 피연산자 중 하나라도 true일 경우 true
- !: 논리 부정 (NOT) 피연산자 결과를 반대로 바꾼다

#### **삼항 연산자**

- 조건식 ? 식1 : 식2
- 조건식이 참일 경우 식1 수행
- 조건식이 거짓일 경우 식2 수행

#### **복합 대입 연산자**

- +=, -=, \*=, /=, …
- i+=1 → i = = i+1

## **제어문 (조건문)**

---

### **if 문**

- 조건식의 결과에 따라 블록 실행 여부가 결정
- 조건식: true/false 값을 산출할 수 있는 연산식 또는 boolean 타입 변수가 올 수 있음
- if (조건식) { 실행할 문장1; 실행할 문장2; ... }
- 조건식이 참일 경우 문장들을 실행하고, 거짓일 경우 실행하지 않음
- 실행할 문장이 하나라면 중괄호 생략 가능

#### **if-else 문**

- 조건식의 결과에 따라 실행할 블록 결정
- if (조건식) { 실행할 문장1; 실행할 문장2; ... } else { 실행할 문장a; ... }
- 조건식이 참일 경우 if 블록의 문장들을 실행하고, 거짓일 경우 else 블록의 문장들을 실행
- 실행할 문장이 하나라면 중괄호 생략 가능

#### **중첩 if 문**

- 조건문 안에 조건문을 넣어 사용함
- if (조건식A) { if (조건식B) { 조건식 A, B 모두 참일 경우 수해할 문장; } else { 조건식 A는 참, B는 거짓일 경우 수행할 문장; } } else { 조건식 A가 거짓일 경우 수행할 문장; }
- 중첩의 횟수에는 제한이 없음

#### **if - else if - else 문**

- 조건식의 결과에 따라 실행할 블록 결정
- if (조건식) { 실행할 문장1; ... } else if (조건식) { 실행할 문장a; ... } ... { } else { 실행할 문장A; ... }
- 조건식이 참일 경우 해당 블록의 문장들을 실행하고, 거짓일 경우 다음 조건식을 확인한다

#### **switch 문**

- 인자로 선택변수를 받아 변수의 값에 따라서 실행문이 결정
- switch (수식) { case 값1: 실행문 A; break; case 값2: 실행문 B; break; default: 실행문 C; }

#### **주의사항!**

1.  수식에 올 수 있는 것
    - 1.4 버전까지 byte, short, char, int
    - 1.5 버전부터 enum 클래스 타입
    - 1.7 버전부터 String 클래스 타입
2.  break문 없이도 사용이 가능
3.  default ⇒ else 의 역할과 동일하다

## **제어문 (반복문)**

---

### **for 문**

```
for (초기화식; 조건식; 증감식) {
	반복 수행할 문장
}
```

- 초기화는 반복문이 시작될 때 한 번 실행됨
- 조건식이 false 문이면 반복문 종료
- 증감식은 반복문의 반복이 끝나면 실행됨
- 초기화식, 증감식은 (,) 를 이용하여 둘 이상을 작성할 수 있음
- 필요하지 않은 부분은 생략할 수 있음 for (;;) 무한 루프
- 반복횟수를 알고 있을 때 유용

#### **중첩 for 문**

- for문은 다른 for문을 내포할 수 있음
- for (초기화식; 조건식; 증감식) { for (초기화식; 조건식; 증감식) { 반복 수행할 문장 } }

#### **while 문**

```
while (조건식) {
	반복 수행할 문장;
}
```

- 조건식이 true일 경우에 계속해서 반복
- (조건식이 거짓이 될 때까지 문장을 반복 수행)
- 조건식 생략 불가능

#### **do while 문**

```
do {
	반복 수행할 문장
} while (조건식) ;
```

- 블록 내용을 먼저 수행 후 조건식 판단 (최소 한 번은 수행)
- 조건식이 true일 경우에 계속해서 반복
- (조건식이 거짓이 될 때까지 문장을 반복 수행)
- 조건식 생략 불가능

#### **break**

- switch, while, do-while, for 문의 블록에서 빠져나오기 위해서 사용
- 반복문에 이름 (라벨)을 붙여 한번에 빠져나올 수 있음

#### **continue**

- 반복문의 특정 지점에서 제어를 반복문의 처음으로 보냄
- 반복문에 이름 (라벨)을 붙여 제어할 수 있음
