---
layout: default
title: CPU의 작동 원리
nav_order: 5004
parent: CS
---

# Chap4 CPU의 작동 원리

# 04 CPU의 작동 원리

## 04-1 ALU와 제어장치

- CPU의 구성 요소: ALU와 제어 장치
- ALU와 제어 장치의 정보 처리 방식 및 역할

## ALU

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbI6AM2%2FbtssqwrGlwM%2FTELeIAwlch5Diork7S0Q9K%2Fimg.png)

ALU가 연산을 하기 위해서는 피연산자와 수행할 연산이 필요하다.

ALU는 레지스터로부터 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려 주는 제어 신호를 받아들인다.

연산 수행 후, 연산 결과는 메모리에 바로 저장되지 않고 레지스터에 저장된다. 이때, 연산 결과는 특정 숫자나 문자가 될 수도 있고, 메모리 주소가 될 수도 있다.

### 플래그

ALU는 연산 결과와 더불어 플래그를 내보낸다. 연산 결과값이 음수일 경우 음수라는 정보를 보내거나, 연산 결과가 연산 결과를 담을 레지스터보다 클 때 ‘결과값이 너무 크다’는 정보도 보낸다.

| 플래그 종류       | 의미                                               | 사용 예시                                                     |
| ----------------- | -------------------------------------------------- | ------------------------------------------------------------- |
| 부호 플래그       | 연산 결과의 부호 나타냄                            | 1일 경우 결과는 음수, 0일 경우 결과는 양수                    |
| 제로 플래그       | 연산 결과가 0인지                                  | 1인 경우 연산 결과는 0, 0일 경우 연산 결과는 0이 아님         |
| 캐리 플래그       | 연산 결과 올림수나 빌림수가 발생했는지             | 1일 경우 올림수나 빌림수가 발생했고, 0일 경우 발생하지 않았음 |
| 오버플로우 플래그 | 오버플로우가 발생했는지                            | 1일 경우 오버플로우 발생, 0일 경우 발생하지 않았음            |
| 인터럽트 플래그   | 인터럽트가 가능한지                                | 1일 경우 인터럽트 가능, 0일 경우 인터럽트 불가능              |
| 슈퍼바이저 플래그 | 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지 | 1일 경우 커널 모드, 0일 경우 사용자 모드                      |

플래그들은 플래그 레지스터에 저장되고 이 정보를 읽음으로써 연산 결과에 대한 추가 정보를 얻을 수 있다.

## 제어장치

![image](https://blog.kakaocdn.net/dn/bI6AM2/btssqwrGlwM/TELeIAwlch5Diork7S0Q9K/img.png)

### 제어장치가 받아들이는 정보

클럭 신호, 해석해야 할 명령어, 플래그 레지스터 속 플래그 값, 제어 신호 in 시스템 버스

1.  클럭 신호
2.  클럭(clock)이란 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
3.  해석해야 할 명령어
4.  CPU가 해석해야 할 명령어는 명령어 레지스터에 저장되고, 제어장치는 이 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 후, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려줌.
5.  플래그 레지스터 속 플래그 값
6.  플래그 값을 참고하여 제어 신호 발생기킴
7.  시스템 버스 중 제어 버스로 전달된 제어 신호

### 제어장치가 내보내는 정보

1.  CPU 외부에 전달하는 제어 신호 - 제어 버스에 제어 신호 전달
    1.  메모리에 전달하는 제어 신호: 메모리에 저장된 값을 읽거나 쓸 때
    2.  입출력 장치에 전달하는 제어 신호: 입출력장치의 값을 읽거나 입출력장치에 새로운 값을 쓰고 싶을 때
2.  CPU 내부에 전달하는 제어 신호
    1.  ALU에 전달하는 제어 신호: 수행할 연산을 지시하기 위해
    2.  레지스터에 전달하는 제어 신호: 레지스터 간 데이터 이동, 저장된 명령어 해석

## 04-2 레지스터

- 레지스터의 종류와 역할
- 명령어가 처리되는 과정

### 알아야 할 레지스터

1.  프로그램 카운터
2.  명령어 레지스터
3.  메모리 주소 레지스터
4.  메모리 버퍼 레지스터
5.  플래그 레지스터
6.  범용 레지스터
7.  스택 포인터
8.  베이스 레지스터

**프로그램 카운터 PC: Program Counter**

**= 명령어 포인터 IP: Instruction Pointer**

메모리에서 가져올 명령어의 주소 저장

**명령어 레지스터 IR: Instruction Register**

방금 메모리에서 읽어 들인 명령어 저장

제어 장치는 명령어 레지스터 내부 명령어를 받아들이고 해석한 뒤 제어 신호 내보냄

**메모리 주소 레지스터 MAR: Memory Address Register**

CPU가 읽어 들이고자 하는 주소값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거침

**메모리 버퍼 레지스터 MBR: Memory Buffer Register**

메모리와 주고받을 값(데이터와 명령어)을 지정하는 레지스터

메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거침

CPU가 주소 버스로 내보낼 값이 메모리 레지스터를 거친다면, 데이터 버스로 주고받을 값은 메모리 버퍼 레지스터를 거침

메모리에 저장된 프로그램을 실행하는 과정에서 프로그램 카운터, 명령어 레지스터, 메모리 주소 레지스터, 메모리 버퍼 레지스터에 어떤 값이 담길까?

1.  CPU로 실행할 프로그램이 1000번지부터 1500번지까지 있다고 가정해 보자. 그리고 1000번지에는 1101(2) 이 저장되어 있다고 하자!
2.  프로그램을 처음부터 실행하기 위해 프로그램 카운터에는 1000이 저장된다. 이는 메모리에서 가져올 명령어가 1000번지에 있다는 것을 의미한다.
3.  1000번지를 읽어 들이기 위해서는 주소 버스로 1000번지를 내보내야 한다. 메모리 주소 레지스터에는 1000이 저장된다.
4.  ‘메모리 읽기’ 제어 신호와 메모리 주소 레지스터 값이 각각 제어 버스와 주소 버스를 통해 메모리로 보내진다.
5.  메모리 1000번지에 저장된 값은 데이터 버스를 통해 메모리 버퍼 레지스터로 전달되고, 프로그램 카운터는 증가되어 다음 명령어를 읽어 들일 준비를 합니다.
6.  프로그램 카운터가 증가하여 1000번지 명령어 처리가 끝나고 1001 번지 (다음 명령어) 로 넘어간다.
7.  메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동한다.
8.  제어 장치는 명령어 레지스터의 명령어를 해석하고 제어 신호를 발생시킨다.

**범용 레지스터 general purpose register**

다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터

데이터와 주소를 모두 저장할 수 있고 일반적으로 CPU 안에는 여러 개의 범용 레지스터가 있다.

**플래그 레지스터**

ALU 연산 결과에 따른 플래그를 플래그 레지스터에 저장한다. 연산 결과 또는 CPU 상태에 대한 부가적인 정보 저장

### 특정 레지스터를 이용한 주소 지정 방식 (1) : 스택 주소 지정 방식

주소 지정에 사용할 수 있는 레지스터: 스택 포인터, 베이스 레지스터

스택 포인터: 스택 주소 지정 방식에 사용

프로그램 카운터, 베이스 레지스터: 변위 주소 지정 방식에 사용

**스택 주소 지정 방식**이란?

스택과 스택 포인터를 이용한 주소 지정 방식

스택은 LIFO 자료 구조로 스택 포인터란 스택의 꼭대기를 가리키는 레지스터이다.

→ 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터

스택은 메모리 안에 위치하고, 이를 **스택 영역**이라 한다.

### 특정 레지스터를 이용한 주소 지정 방식 (2) : 변위 주소 지정 방식 displacement addressing mode

오퍼랜드의 필드값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식

> 오퍼랜드 + 레지스터 ⇒ 유효 주소

이 방식으로 유효 주소를 얻어내는 방식

오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 상대 주소 지정 방식, 베이스 레지스터 지정 방식 등으로 나뉜다.

### 상대 주소 지정 방식 relative addressing mode

오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식

모든 코드를 실행하는 것이 아닌 분기하여 특정 주소의 코드를 실행할 때 사용

프로그램 카운터에는 읽어 들을 명령어의 주소가 저장되어 있고, 오퍼랜드가 음수 (예: -3) 이었다면 CPU는 읽어들이기로 한 명령어로부터 ‘세 번째 이전 (-3)’ 상태로 접근

→ 실행하려는 명령어의 세 칸 이전 번지 명령어 실행

### 베이스 레지스터 주소 지정 방식 base-register addressing mode

오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식

> 오퍼랜드 + 베이스 레지스터 ⇒ 유효 주소

베이스 레지스터: 기준 주소

오퍼랜드: 기준 주소로부터 떨어진 거리

베이스 레지스터 주소 지정 방식은 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지 연산하여 유효 주소를 얻어내는 방식

## 04-3 명령어 사이클과 인터럽트

**명령어 사이클**

CPU가 하나의 명령어를 처리하는 과정에는 어떤 정해진 흐름이 있고, CPU는 그 흐름을 반복하며 명령어들을 처리해 나간다. 이때 명령어를 처리하는 정형화된 흐름을 명령어 사이클이라고 한다.

**인터럽트**

CPU가 정해진 흐름에 따라 명령어를 처리하다가 이 흐름이 끊어지는 상황이 발생하는데 이것을 인터럽트라고 한다.

### 명령어 사이클 instuction cycle

우리가 실행하는 프로그램은 수많은 명령어로 이루어져 있고, CPU는 이 명령어들을 하나씩 실행한다. 이때 명령어들이 실행되는 일정한 주기를 “명령어 사이클” 이라고 한다.

명령어를 실행하려면 어떻게 해야 할까?

→ 먼저 명령어를 메모리에서 CPU로 가져와야 한다 :: **인출 사이클** fetch cycle

→ 명령어를 실행한다 :: **실행 사이클** execution cycle

간단히 표현하면, 명령어를 가져오고, 실행하는 과정을 계속 반복한다. 하지만 명령어를 인출하여 CPU로 가져왔다 하더라도 바로 실행할 수 없는 경우도 있다.

예를 들어, 간접 주소 지정 방식으로 주소가 지정될 경우 (유효 주소의 주소를 명시하는 방식) 한 번 더 메모리에 접근해야 하기 때문이다. 이 과정을 간접 사이클이라 한다.

**간접 사이클** indirect cycle

명령어의 종류에 따라

- 인출 → 실행
- 인출 → 간접 → 실행

### 인터럽트 interrupt

CPU가 수행 중인 작업은 방해를 받아 잠시 중단될 수 있는데, 이때 작업을 방해하는 신호를 인터럽트라고 한다.

작업을 중단해야 하는 상황은 어떻게 발생할까?

- CPU가 꼭 주목해야 할 때
- CPU가 얼른 처리해야 할 다른 작업이 생겼을 때

**인터럽트의 종류**: 동기 인터럽트, 비동기 인터럽트

1.  동기 인터럽트: 예외 exceptionCPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 때, CPU가 실행하는 프로그래밍 상 오류 같은 예외 상황에 마주쳤을 때
2.  CPU에 의해 발생하는 인터럽트
3.  비동기 인터럽트: 하드웨어 인터럽트
    - CPU가 프린터와 같은 입출력장치에 입출력 작업을 부탁하면 작업을 끝낸 입출력장치가 CPU에 완료 알림 (인터럽트) 을 보낸다
    - 키보드, 마우스와 같은 입출력장치가 어떠한 입력을 받아들였을 때 이를 처리하기 위해 CPU에 입력 알림 (인터럽트) 을 보낸다
4.  주로 입출력 장치에 의해 발생

### 하드웨어 인터럽트

알림과 같은 인터럽트이다.

CPU 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트를 사용한다.

⇒ 왜?

어떤 작업을 하고 있을 때, 완료 알림을 보냄으로써 작업 진행 도중 다른 작업을 병행할 수 있음.

알림을 보내지 않는다면 완료되기만을 기다려야 하기 때문에 사이클이 낭비됨

**하드웨어 인터럽트 처리 순서**

1.  입출력장치: CPU에 인터럽트 요청 신호 전송
2.  CPU: 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부 확인
3.  CPU: 인터럽트 요청 확인 후 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 확인
4.  인터럽트를 받아들일 수 있다면? CPU는 지금까지의 작업을 백업
5.  CPU: 인터럽트 백터를 참 조하여 인터럽트 서비스 루틴을 실행
6.  인터럽트 서비스 루틴 실행 후 4단계에서 백업해둔 작업을 복구하여 계속 실행

<용어들>

- 인터럽트 요청 신호
- 인터럽트는 CPU의 정상적인 실행 흐름을 끊는 것이기에 인터럽트 전 인터럽트가 가능한지 물어보는 신호와 같다
- 인터럽트 플래그만약 ‘불가능’으로 설정되어 있다면 인터럽트 요청이 들어와도 그 요청을 무시한다하지만, 모든 인터럽트 요청을 인터럽트 플래그로 막을 수 있는 것은 아니다.막을 수 없는 인터럽트 non maskable Interrupt ex) 정전, 하드웨어 고장으로 인한 인터럽트
- 막을 수 있는 인터럽트 maskable Interrupt
- ‘가능’으로 설정되어 있다면 요청을 받아들이고 인터럽트 처리
- 하드웨어 인터럽트를 받아들일지, 무시할지를 결정하는 플래그
- 인터럽트 서비스 루틴 ISR: Interrupt Service Routine = 인터럽트 핸들러 interrupt handler어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램

  1.  정상적으로 작업 실행
  2.  인터럽트 발생
  3.  인터럽트 서비스 루틴으로 점프
  4.  인터럽트 서비스 루틴 실행
  5.  기존 작업으로 점프
  6.  기존 작업 수행 재개

- CPU가 인터럽트를 처리한다 ⇒ 인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다
- 인터럽트를 처리하기 위한 프로그램
- 인터럽트 벡터 interrupt vector인터럽트 벡터를 통해 서비스 루틴의 시작 주소를 알 수 있고 CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 처음부터 실행함
- 다양한 서비스 루틴이 존재하고, 이를 구분하기 위한 정보

**예외의 종류**

- 폴트
- 트랩
- 중단
- 소프트웨어 인터럽트

예외가 발생하면 CPU는 하던 일을 중단하고 해당 예외를 처리한다. 예외를 처리하고 나면 CPU는 다시 본래 하던 작업으로 되돌아와 실행을 재개한다.

CPU가 본래 하던 작업으로 되돌아왔을 때

1.  발생한 명령어부터 실행하는지
2.  예외가 발생한 명령어의 다음 명령어부터 실행하는지

⇒ 이에 따라 폴트와 트랩으로 나뉜다.

**폴트** fault

예외를 처리한 후 예외가 발생한 명령어부터 실행을 재개하는 예외

**트랩** trap

예외를 처리한 후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외

**중단** abort

CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생하는 예외

**소프트웨어 인터럽트** software interrupt

시스템 호출이 발생했을 때… (차후 배움)
